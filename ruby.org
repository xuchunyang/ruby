#+PROPERTY: header-args:ruby :results output

* 控制语句
** 条件（比较）

#+BEGIN_SRC ruby
p (1 == 1)
p (1 == 2)
p ("Ruby" == "Ruby")
p ("Ruby" == "Rubies")
p (1 != 1)
p (1 != 2)
p /a/ =~ "hello"
#+END_SRC

#+RESULTS:
: true
: false
: true
: false
: false
: true
: nil

*** Ruby 的真假值

#+NAME: Ruby 的真假值
| 假 | false, nil                     |
| 真 | 除了 flase 和 nil 外的所有对象 |

*** 逻辑运算（与、或、非）

- &&
- ||
- ~


** if

#+BEGIN_SRC ruby
  x = 20
  if x >= 10
    puts "bigger"
  else
    puts "smaller"
  end
#+END_SRC

#+RESULTS:
: bigger

** unless

#+BEGIN_SRC ruby
puts "Hello, Ruby!" unless nil
#+END_SRC

#+RESULTS:
: Hello, Ruby!

注意 if 和 unless 都可以作为修饰符

#+BEGIN_SRC ruby
puts "Hello" if true
puts "world" unless false
#+END_SRC

#+RESULTS:
: Hello
: world

** case

#+NAME: case.rb
#+BEGIN_SRC ruby
  tags = [ "a", "img", "pre"]
  tags.each do |tagname|
    case tagname
    when "p", "a", "i", "b", "blockquote"
      puts "#{tagname} has child."
    when "img", "br"
      puts "#{tagname} has no child."
    else
      puts "#{tagname} cannot be used."
    end
  end
#+END_SRC

#+RESULTS: case.rb
: a has child.
: img has no child.
: pre cannot be used.

#+NAME: case_class.rb
#+BEGIN_SRC ruby
  array = [ "a", 1, nil ]
  array.each do |item|
    case item
    when String
      puts "Item is a String"
    when Numeric
      puts "Item is a Number"
    else
      puts "Item is something."
    end
  end
#+END_SRC

#+RESULTS: case_class.rb
: Item is a String
: Item is a Number
: Item is something.

#+NAME: case_regexp.rb
#+BEGIN_SRC ruby
  File.read("/var/mail/xcy").each_line do |line|
    case line
    when /^From:/i
      puts "发现寄件人信息"
    when /^To:/i
      puts "发现收件人信息"
    when /^Subject:/i
      puts "发现主题信息"
    when /^$/
      puts "头部解析完毕"
      exit
    else
    end
  end
#+END_SRC

#+RESULTS: case_regexp.rb
: 发现收件人信息
: 发现主题信息
: 发现寄件人信息
: 头部解析完毕

*** case-when 中的比较 ~===~

~===~ 表示范围更广的相等，有三个作用：

1. 跟 == 相同
2. 跟 =~ 相同
3. 判断右边的对象是不是属于左边的类

#+BEGIN_SRC ruby
  p "a" === "a"
  # p "a" === String
  p String === "a"
  p /a/ === "a love letter"
#+END_SRC

#+RESULTS:
: true
: true
: true

** 循环

#+BEGIN_SRC ruby
  i = 1
  while i <= 3
    puts i
    i = i + 1
  end
#+END_SRC

#+RESULTS:
: 1
: 2
: 3

#+BEGIN_SRC ruby
  3.times do
    puts "I am learning Ruby."
  end
#+END_SRC

#+RESULTS:
: I am learning Ruby.
: I am learning Ruby.
: I am learning Ruby.

* 数组 (Array)

** 初始化数组、访问和修改数组元素、数组长度
#+BEGIN_SRC ruby
names = ["李白", "杜甫", "白居易"]
p names
print "第一个名字是: ", names[0], "\n"

names[0] = "李商隐"
p names
print "第一个名字是: ", names[0], "\n"

names[10] = "陈子昂"
p names

p names.size
#+END_SRC

#+RESULTS:
: ["李白", "杜甫", "白居易"]
: 第一个名字是: 李白
: ["李商隐", "杜甫", "白居易"]
: 第一个名字是: 李商隐
: ["李商隐", "杜甫", "白居易", nil, nil, nil, nil, nil, nil, nil, "陈子昂"]
: 11

** 循环一个数组

each 是一个带块 (block) 的方法

#+BEGIN_SRC ruby
  names = ["李白", "杜甫", "白居易"]

  names.each do | x |
    puts x
  end
#+END_SRC

#+RESULTS:
: 李白
: 杜甫
: 白居易

* 散列 (hash)

** 符号 (Symbol)

Hash 中的索引常用符号或字符串表示

#+BEGIN_SRC ruby
sym = :foo
sym2 = :"foo"
p sym, sym2

p sym.to_s
p "foo".to_sym
#+END_SRC

#+RESULTS:
: :foo
: :foo
: "foo"
: :foo

** 创建和使用 Hash

#+BEGIN_SRC ruby
info = {:名 => "李白", :字 => "太白", :号 => "青莲居士", :代表作 => ["蜀道难"]}
p info

p info[:名], info[:字], info[:号], info[:代表作]

info[:代表作] = ["蜀道难", "忆秦娥"]
p info[:代表作]
#+END_SRC

#+RESULTS:
: {:名=>"李白", :字=>"太白", :号=>"青莲居士", :代表作=>["蜀道难"]}
: "李白"
: "太白"
: "青莲居士"
: ["蜀道难"]
: ["蜀道难", "忆秦娥"]

** 循环 Hash

#+BEGIN_SRC ruby
  info = {:名 => "李白", :字 => "太白", :号 => "青莲居士", :代表作 => ["蜀道难", "忆秦娥"]}

  info.each do | key, value |
    puts "#{key}: #{value}"
  end
#+END_SRC

#+RESULTS:
: 名: 李白
: 字: 太白
: 号: 青莲居士
: 代表作: ["蜀道难", "忆秦娥"]

* 正则表达式 (Regular Expression)

#+BEGIN_SRC ruby
p (/cde/ =~ "abcdefg")
p (/ruby/ =~ "I am learning Ruby.")
p (/ruby/i =~ "I am learning Ruby.")
#+END_SRC

#+RESULTS:
: 2
: nil
: 14

#+BEGIN_SRC ruby
  names = ["小林", "林", "红叶", "岩雀"]
  names.each do |name|
    if /林/ =~ name
      puts name
    end
  end
#+END_SRC

#+RESULTS:
: 小林
: 林

* 命令行程序

** 参数 ARGV

命令行参数保存在 ARGV 中

#+BEGIN_SRC ruby :tangle print_argv.rb
# -*- coding: utf-8; -*-

puts "首个参数: #{ARGV[0]}"
puts "第二个参数: #{ARGV[1]}"
puts "第三个参数: #{ARGV[2]}"
#+END_SRC

#+BEGIN_SRC sh
ruby print_argv.rb 1st 2nd 3rd
#+END_SRC

#+RESULTS:
| 首个参数:   | 1st |
| 第二个参数: | 2nd |
| 第三个参数: | 3rd |

#+BEGIN_SRC ruby :tangle arg_arith.rb
x = ARGV[0].to_i
y = ARGV[1].to_i

puts "#{x} + #{y} = #{ x + y }"
puts "#{x} - #{y} = #{ x - y }"
puts "#{x} * #{y} = #{ x * y }"
puts "#{x} / #{y} = #{ x / y }"
#+END_SRC

#+BEGIN_SRC sh :results output
ruby arg_arith.rb 5 3
#+END_SRC

#+RESULTS:
: 5 + 3 = 8
: 5 - 3 = 2
: 5 * 3 = 15
: 5 / 3 = 1

** 文件的读取

首先随便创建一个文件：

#+BEGIN_SRC sh :results silent
cal > cal.txt
#+END_SRC

*** 一次性读取

然后使用 Ruby 读取这个文件:

#+BEGIN_SRC ruby
  filename = "cal.txt"
  file = File.open(filename)
  text = file.read
  print text
  file.close
#+END_SRC

#+RESULTS:
:       六月 2017         
: 日 一 二 三 四 五 六  
:              1  2  3  
:  4  5  6  7  8  9 10  
: 11 12 13 14 15 16 17  
: 18 19 20 21 22 _2_3 24  
: 25 26 27 28 29 30     
:                       

或者直接用 File.read 方法

#+BEGIN_SRC ruby
  print File.read("cal.txt")
#+END_SRC

#+RESULTS:
:       六月 2017         
: 日 一 二 三 四 五 六  
:              1  2  3  
:  4  5  6  7  8  9 10  
: 11 12 13 14 15 16 17  
: 18 19 20 21 22 _2_3 24  
: 25 26 27 28 29 30     
:                       

*** 一行一行读取

#+BEGIN_SRC ruby
  filename = "cal.txt"
  file = File.open(filename)
  file.each_line do |line|
    print line
  end
  file.close
#+END_SRC

#+RESULTS:
:       六月 2017         
: 日 一 二 三 四 五 六  
:              1  2  3  
:  4  5  6  7  8  9 10  
: 11 12 13 14 15 16 17  
: 18 19 20 21 22 _2_3 24  
: 25 26 27 28 29 30     
:                       

** simple_grep.rb

#+BEGIN_SRC ruby :tangle simple_grep.rb
  pattern = Regexp.new(ARGV[0])
  filename = ARGV[1]

  file = File.open(filename)
  file.each_line do |line|
    if pattern =~ line
      print line
    end
  end
  file.close
#+END_SRC

#+BEGIN_SRC sh :results output
ruby simple_grep.rb line simple_grep.rb
#+END_SRC

#+RESULTS:
: file.each_line do |line|
:   if pattern =~ line
:     print line

* 方法

#+BEGIN_SRC ruby
  def hello
    puts "Hello, Ruby!"
  end

hello()
#+END_SRC

#+RESULTS:
: Hello, Ruby!

* 加载其它 Ruby 文件

#+BEGIN_SRC ruby :tangle foo.rb
  def foo
    puts "Foo Bar Baz"
  end
#+END_SRC

好吧，可以不用设置 Load Path 了，直接写全路径：

#+BEGIN_SRC ruby
require "./foo"
foo
#+END_SRC

#+RESULTS:
: Foo Bar Baz

另外用 require 可以省略扩展名 ~.rb~

* PP (Pretty-Print 的 p 方法)

注意这个例子不好。

#+BEGIN_SRC ruby
require "pp"

info = {:名 => "李白", :字 => "太白", :号 => "青莲居士", :代表作 => ["蜀道难", "忆秦娥"]}
pp info
#+END_SRC

#+RESULTS:
: {:名=>"李白", :字=>"太白", :号=>"青莲居士", :代表作=>["蜀道难", "忆秦娥"]}

* 变量

#+BEGIN_SRC ruby
    FOO_VERSION = "0.1"             # 常量
    $x = 0                          # 全局
    x = 0                           # 局部变量

    p ARGV
    p RUBY_VERSION
    p __FILE__
    p __LINE__
#+END_SRC

#+RESULTS:
: []
: "2.3.3"
: "-"
: 8

** 多重赋值

#+BEGIN_SRC ruby
  def log() puts "$a = #{$a}, $b = #{$b}"; end

  $a, $b = 1, 2
  log

  $a, $b = $b, $a
  log

  a, b = [1, 2, 3, 4]
  puts "a = #{a}, b = #{b}"

  a, (b, c), d = [1, [2, 3], 4]
  print a, b, c, d, "\n"
  #+END_SRC

#+RESULTS:
: $a = 1, $b = 2
: $a = 2, $b = 1
: a = 1, b = 2
: 1234

